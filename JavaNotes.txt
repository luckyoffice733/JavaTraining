

  variables :
  ==========

  1)variable is used to store the value temporarily.
    A variable is a location in memory(storgae area) to hold data.
   
    Note:
    ======
    Java is a statically-typed language.
    It means that all variables must be declared before they can be used.    

    syntax create variable in java:
    ===============================
    accessmodifier datatype  variablename ;
    default
    private
    protected
    public    

    In java the varibales are

    1)instance variable --
     =================
     is also called non-static variables.

     a)memory is allocated at Heap area of JVM 

     b)For every object their is a separate copy of instance of variables
      available(memory)-- at run time

    c)we can declare the instance variable inside the class
      before or outside  the methods.

    ex:
   ====
    public class Ex1{
               ///instance variables
        int b; --declaration
        int a=10; --declarattion and initialization
         int a,b;
         int a=10,b=30,c;
     //methods
       public static void main(String args[]){
    }
  }


    2)static variable-- 
  =================

   a)For static variables the memory is allocated method area of JVM

   b)the memory is allocated at once

    c)we can declare the variable inside the class  before the method
   using static keyword.
  
   d)instance variable cannot be used directly inside the static
     context(static block,static method) and if we want to access
     the  instance variables inside static context using object.

   e) static variables and methods recommended way to access with help of ClassName.
  
   ex:
   ===
   public class Ex2{

     static int a=10; //static variable.
    //methods  
 
   }                     


  3)local variable --
   ==============
  a)For local variable the memory is allocated
                   at stack  in JVM
     
  b) Local variable is declared inside a method or block.
   
  c)scope the local variable with in the method or block ==>{}.

  d) A local variable which declared must be initialized before you use it.


  ex:
  ====

    public class Ex3
   {

   public void methodOne(){

    int a=10;

    }

    }



  JAVANAMING CONVENTIONS:
  ==========================

  1)CLASSNAME:
  =============
  Class name is a noun  and  the classname should start with Capital Letter and secondWord also
  followed by Capital.

  Ex:
  ===
  class  StudentRegistration{


  }

 2) methodName:
 =============
  method name is verb   and the method name should startwith small letterand next word
  start with capital Letter(camelCase)


  Ex:
  ===
  class Employee{

   void getEmployeeDetails(){

    //statements
   }

   }

  3) variableName:
  ==============

   variableName is also camelCase

  ex:
  ===

   class Employee{
 
     int empId;
     int empName;
     int sal;

   }

  

  Example:
  =======

  write a java program to declare the variables
  =======================================

  class ExampleOnVariables{

  int  studentNo;
  String studentName;
  float  studentMarks;   //instance variables


 public static void main(String args[]){

  System.out.println(studentNo);
  System.out.println(studentName);
  System.out.println(studentMarks);

 }


 }



 Example2:
 ========
  WAP named as ExampleOnVariables1  and declare 
  three instance variables  of type int and 
  create a method named as  getSum() ,return type of method is void and perform sum of two numbers
  and display the sum of two numbers.






 sol:
 ===
 public class ExampleOnVariables1{

 int num1;
 int num2;
 int res;

 public void getSum(){

 res=num1+num2;
 System.out.println("sum of two numbers is "+res);

 }

 public static void main(String args[]){

  ExampleOnVariables1 env1 = new ExampleOnvariables1();
  env1.getSum();

 }}
 }


 oops:
 =====

  1)class
  2)Object
  3)Inheritance
  4)Encapsulation
  5)Abstraction(Interfaces)
  6)Polymorphism

 Class:
 ======

  A class is Blue print(template) for an Object.

  A class is user defined Datatype.

  Example:
  --------
  Class as a Sketch (prototype) or plan of house.
  it contains all the details about the no of floors,doors,windows..etc.
  Based on these plan descriptions we built the house. House is an Object.


 syntax for  creating a class:
 ============================

 class classname
 {
   //Datamemebers(variables)        //to specify object properties 
   //member methods   // to specify object functionality or actions.

 }

 Object:
 =======

 An  Object which exists phsically in the real world.

 An object is an instance of a class(initalization of an object) -->will discuss more this on constructors Topic.

 An object can contain properties(fields) and Actions(behvaiours).

 In java we represent Properties(fields) in the form of datamembers(variables)

 In java we represent Actions(behaviours) in the form of member methods.

 to define Object properties and Actions we require class.

 to perfrom any operations in java  we require Class(template).

  example:
  =======
  Chair is an Object

  properites of chair:- color,material,shape,wheels..etc

  Actions of chair  --  movieable(),seatAdjustable()

  sol:
  =====

  class Chair
 {

  String color="black";
  String material="plastic";

  int wheels = 4; //properties

  public void movieable(){  //actions

  System.out.println("Chair is moveable");

 }

 }


 How to create object for class:
 ===============================

 1) new operator:
= ===============

  Using  new operator we can create the Object for a class

  syntax:
 =======

  classname  referencename = new classname(); //it will allocates memory in JVM On HeapMemory.

  ex:
  ===

  Chair c = new Chair();


  to call the instance data members and instance methods;
  ========================================================

  syntax:
  =======

   referencename.variablename  //to call instance variables

   referencename.methodname() // to call instance methods

   ex:
  ====

  System.out.println(c.color);
  System.out.println(c.wheels); //to call instance variables

   c.movieable();//to call instance method


  to call static datamembers and static methods:
  ==============================================

  syntax:
  ========

  classname.variable  --- to call a static variable

  classname.methodname --to call static methods.


  How to define methods:
   ======================

     1) instance methods or concrete methods /non-static methods
     --------------------------------------------------------------

    syntax:
    ========
     AccessModifer returntype methodname(if any arguments){

     //to perform certain a task

    }
      note:
     ======

     AccessModifer:-(public,protected,private,default)
      return type :- primitive datatypes or object References
                     if not primitive or object it must be void(empty).

    ex:
    ===
     void  methodOne(){

      //any statements

      }

     or

     public  int getAddition(int x,int x){
  
    //logic
    //return type of variable
    }

    or

    protected float getEmpSalay(int id){

    //logic to get the salary based on id
     //return;
    }


   static methods:
   ===============

    A static method is method is declared using a keyword called
     static.

   syntax:
   ========

    accessmodifiers static  returntype methodname(if any arguemnts){

     //

     }

  ex:
  ====

    public static void main(String args[]){

   //logic
    }


    Abstract Method:
    ================

    A abstract method is a method , it  contains  only method declaration
    but not definition .

    syntax:
    =======

     public abstract retruntype methodname(if any arguments);
      ex:
      public abstract void methodOne();

     note:
     =====
     if a class contain atleast one abstract method then compiler will
     force the user or Developer to declare the class as abstract.


   Example:
   =======
     1) WAP  named as ExampleOnMethods 
     a) create a instance method(getEmpSal) which return int type value and
      perform sum of two numbers by passing values to method.

     b)create a static method named as studentTotalMarks(three parameters of type int)
      and return the sum of the three parameters




   sol:
    ===
  public class ExampleOnMethods{
      
  public  int getEmpSal(int x,int y){
      
        int z=x+y;
        return z;
    
     }

    public static int studentTotalMarks(int m1,int m2, int m3){
       
                 int total=m1+m2+m3;

                return total;        
     }
     public static void main(String args[]){

        ExampleOnMethods enm =new  ExampleOnMethods();
   
                int res   =     enm.getEmpSal(1000,3000);//calling instance method
               
        int res1=   ExampleOnMethods.studentTotalMarks(45,60,36); //calling static method

               System.out.println("sum of employee salaries : "+res);
              System.out.println("sum of marsk of a student : "+res1);
    } 

}

Inheritance:
  ============
   Acquiring the properties and methods  from one class to
   another class is called inheritance.

     or

   Acquiring the properties and methods from Parent Class(super class) to 
   Child Class(subclass) is called inheritance.

   the main advantage of inheritance is code  reuseability.

    By using extend keyword  we can get the properties and method from 
    parent class to child class.

    Inheritance is  also called  as IS-A a relation.

   note:
   =====
   --  It is recommended to create the object for child class
    in inheritance concept.

   --In java every class by default extends from Object class.

   -- Object is the super class for all the classes.


  syntax:
  =======

  public  class Parent {

   //data members;

   //member methods;

  }

   public class Child extends Parent{


   //it acquires the datamembers and members from parent

  //and it child class data members and member methods.
     
   public static void main(String args){

   Child c = new Child();

   //using child object we can call parent class datamemebrs and members.

  //using child object we can call it own data memeber and member methods.

 }


 Operators:
 =========

 1)Arithmatic operators:
 ===================
 this operators are used to perfrom calculations between two operands.

 +   -- ADDITION
 -     --SUBSTRACTION
 *   --MULTIPLICATION
 /    --DIVISION     --- IT WILL RETRUN QUOTIENT

 %    -- MODULES  ---IT WILL RETURN REMAINDER


 2)Relational operators:
 ==================

  >    GREATER THAN
  >=    GREATER THAN OR EQUALS TO
  <     LESSTHAN
  <=     LESSTHAN OR EQUALS TO
  !=     NOT EQUALS TO
  ==    EQUALS TO 

 3)Logical operators:
 ================
  &&  --- logical and
  ||      --logical or
  ^      --logical XOR
  !     --- logical Not

4)Increment and Decrement operators
  
   ++,--,+=,-=,%=

 Example:
 =======

 1)WAP  to perform addition,substraction,division,modules.
  and display sum of numbers,sub of numbers or.......





  Conditional operator:
  =================
  this operator is used to make Conditional Expressions.

  syntax:
  ======
  Datatype variableName =Expression1?Expression2:Expression3;

   if Expression1 condition is matched it will return expression2
.
   if Expression 1 condition is not matched it will retrun Express3



  Ex:
  ===

  int a=10;
  int b=20;

  int value1=(a<b)?a:b;

  int value2=(a>b)?a:b;





 Conditional Statements:
 ======================
  1)if
  ===

  syntax:
  =======
  if(condition){
  
  //true statments;
  }

  note:
  =====
  In if condition it contains only one statement braces
  are optional but this statment should not be initilization statement.



  Example:
  =======
  1)WAp to compare two int variables and print which is greater.
   using if-else condition.


  if-else
  ======
    syntax:
    ======
    if(condition){
   
      //true statments   
    
    }else{
 
      //else /false statements
     }





  if-else-if:
  ===========
  to check multiple conditions

  syntax:
  ======

  if(condition1){

  //statements
  
   }else if(condition2){
   //statements
 
   }else{
       //statements
   }

  ex:
   ===
    WAp to compare three int variables and print which is greater.
    using if-else-if condition and logical operators (&& or ||).



  switch-case:
  ===========
   to check multiple condition based on expression

    syntax:
    =======
    switch(expresssion){

       case  cond1 : statements;
                       break;
       case  cond2 : statements;
                        break;
        case cond3 : statements;
                       break;
        case cond4 : statements;
                       break; 
        default : statement;
    }

    Example 
    ++++++++
    wAp to perform arthematic operations using switch case expresssion .
    


   Iterative statments:  Loops
   =====================+++++===

   Loops are used to repeat a block of code.
   
   Example:
   -------
    If you want to show a message 10 times, then rather than typing
    the same code or message 10 times , you can use a loop.

    In Java, there are three types of loops.

    >while loop
    >do...while loop
    >for loop


   While loop:
   ===========
    while loop is used to run a specific code until a certain condition is met.

   to repeat the statements until the condition become true.

   syntax:
   =======

   initialize a variable;

    while(condition)
    {
    //statements;

    //increment/decrement

    }

   ex:
   ==
   Write a  java program to display Numbers from 1 to 10
   Write a java pgroam to sum of 10 Numbers only.
   write a program to display multiplication table of 2 using while loop;





  sol:
  ===

   public class ExampleOnWhile{

   public static void main(String args[]){

   int i=1;
    int n=2;

   while(i<=10){

   System.out.println(n+ " X " +i+" = "+(n*i));
   i++;    //i=i+1; or //i+=1

   }}
  }

 2) WAP to print 1 to 10 integers using while loop.

   sol:
  ===

   public class ExampleOnIntegers{

   public static void main(String args[]){

   int i=1;

   while(i<=10){

   System.out.println(i);
  i++
  }

 }
 }

 for loop
 ========

 syntax:
 =======

  for(initilization;condition;increment/decrement){

  //statements

  }

  ex:
  ===
 Write a  java program to display Numbers from 1 to 10
 Write a java pgroam to sum of 10 Numbers only

  Assign: WAP to display multiplication table of 5 using for loop;

 sol:
 ====
 public class ExampleOnFor{
 public static void main(String args[]){

 int n=5;

 for(int i=1;i<=10;i++){

 System.out.println(n+" X "+i+" = "+(n*i));

 }
  }
 }


  do-while loop
  =============
   do..while loop is similar to while loop.
   However, the body of do..while loop is executed once before the condition is checked .


  syntax:
   =======
	initilization variable;
   do{

   //statements;
   //increment/decrement

    }while(condition);

  note:
  =====
  the statements will execute atleast one time before checking the condition.



 Example:
 =======
   Write a  java program to display Numbers from 1 to 10
   Write a java program to sum of 10 Numbers only
  Assign: write a java program to print 1 to 10 integers using do-while loop.
  WAP to print multiplication table of 4


 

sol:
   ===
  public class ExampleOndoWhile{

  public static void main(String args[]){

     int i=1;
   do{
        System.out.println(i);
     i++;
    }while(i<=10);
  }
 

Assigment:
==========
 1)WAP to check given number is prime number or not.
 2)WAP to check given year is a leap year or not
 3)WAP to fibnoic series from 1 to 10

 
 for -foreach loop ---from jdk 1.5 
 ===================================

 In JDK 1.5 introduced a new for loop known as 
 foreach loop or enhanced for loop, 
 which enables you to traverse the complete array or collection object sequentially 
 without using an index variable.

  syntax:
  ========
  for(type of array/collection variableName : Object of array/collection){

 //statements;

  }

   
  break :
  ========
  The break statement in java terminated the loop immediately and
  the control of the progrem moves to the next statement.


  continue:
  =========
  The continue statements skips the current iteration of a loop.

  After the continue the statement, the program moves to the end of the loop.


 Abstraction:
 ============
 abstraction is a process of hideing implementation details
 and showing useful information to user is called abstraction.

 The advantage of abstraction is secuirty.

 we can acheive full abstraction in java 
 using interfaces and abstract classes

 We can achieve multiple inheritance by implementing multiple interfaces.

 ex:
 ===
 ATM--withdrawal a money

note:
======
we can declare the class as abstract but even it doesnot contain
any abstract method to acheive security i.e, for the class
it will not allow to create  object for the class directly.

ex:
====

 public abstract class Ex1{

 //instance methods
  and abstract methods
 }


 Interface:
 ==========

 --> An interface which contains set of abstract  methods.

 -->Interface used for SRS(software requirement specification or abstract).

 -->An interface contain variables and these variable must be static and final(constants)

-->  By using implements keyworkd we can provide implementation for the abstract methods.

There are a few things to keep in mind when using an Interface in Java:
------------------------------------------------------------------------
The same signature must be used when overriding interface methods.
Interface methods must be implemented in classes that are not abstract.
Zero, one, or more interfaces can be implemented by a class at a time.
An interface in Java can extend another interface just like a class extends another class.

   syntax:
  =======

  public interface InterfaceName{

   //constant variables;

   //abstract methods
   
   accessmodifiers abstract returntype methodName(if any parameters);


   }

 -->once the interface is created who will provide the implementation,  
    developer is responsible to provide implementaions for the interface

 --> How to provide implementation
    to provide implementations a class must implements the 
    interface and provide the implementation for all the abstract methods.

  note:
 =====

  1)if we not provide implementation for any one abstract  method then
  declare the class as abstract.

 2)we can not create the object for abstract class directly.

 3) to create the object for the abstract class,create one more
  class which extends from abstract class  and provide
  the implementation for the abstract method

 4) create a object for new created class which extends from 
   abstract class

 5) call the data members and memeber methods of it own class
   as well as abstract  class


Example:
========

  1) create a interface  named as MyApp

  2) this interface contain two abstracts methods
     a)public abstract int getSum(int x,int y);
    b)public abstract  int getAddition(int x,int y,int z);

  3) create a class named as ExampleOnInterface   which implements
    MyApp interface 
   note:- provide implementation for all abstract methods.

  4) create a Object for implementation class and call those methods.







Sol:
-----
interface:
=======

public interface MyApp{

  public abstract int getSum(int x,int y);
   public abstract int getAdditions(int x,int y,int z);

}

Implementation Class
=================

public class ExampleOnInterface implements  MyApp{

     public int getSum( int x,int y){
      
      int z=x+y;
      
      return z;   

    }

    public int getAddition(int x,int y,int z){
   
        return x+y+z;
   }


public static void main(String args[]){

ExampleOnInterface eoi = new ExampleOnInterface();

    int res =     eoi.getSum(40,50);
    System.out.println("sum of two numbers is : "+res);
   
    int res1 = eoi.getAddition(30,40,30);
    System.out.println("Sum of three numbers is :"+res1)
   
 //Interface Reference variable Holding its implementation class Object

   MyApp   mp = new ExampleOnInterface();

    int result = mp.getSum(50,50);

    System.out.println("sum of two numbers is : using interface reference : "+result);
          
   int result2 = mp.getAddition(50,50,60);

    System.out.println("sum of three numbers is : using interface reference : "+result2);

}


}





Example:2
=========
  1) create a interface named as MyInterface

  2) this Interface contain abstract methods 

   a) int methodOne();
    b) String methodTwo(String s);
    c) void  methodThree();

  3)create a class named as ExImp1 which implements the interface
  MyInterface 
  note:-  provide the implementation for two methods methodOne
         and methodTwo.
         Then declare the class as abstract

  4)create a one more class named as ExImp2 extends from above class
  ExImp1 and provide the implementation for abstract method
   methodThree();
  5) create a object for ExImp2 class and call the methods








public interface MyInterface{

       public abstract int methodOne();
      public abstract  String methodTwo(String s);
       public abstract void methodThree();
}

public class ExImp1 implements MyInterface{

    public int methodOne(){
    int a=10;
   System.out.println("we are in method One");
   return a;
   }

    public String methodTwo(String s){
    
     return "we are in methodTwo of ExImpl Class"
    }


}


4)create a one more class named as ExImp2 extends from above class
  ExImp1 and provide the implementation for abstract method
   methodThree();
5) create a object for ExImp2(two ways) class and call the methods
   

public class ExImp2 extends ExImp1{

public void methodThree(){

System.out.println("we are in method Three of ExImp2");

}

 public static void main(String args[]){

    ExImp2 ex2 = new ExImp2();
   
    String wc = ex2.methodTwo("Welcome");
   System.out.println(wc);
   
     ex2.methodThree();

}




}


Example3:
========
a)
public interface I1{

     public abstract String getMessage();
     void display();
     
}
public interface I2 extends I1{

   public abstract String getMessage();
   void methodTwo();

}

b) create a class named as ExampleOnInterface2 which
  will provide the implementation for I2(I2 interface inherits  the properties and
                                                                  abstract methods from I1)

sol:
===

public class ExampleOnInterface2 implements I2{

   public String getMessage(){

    return "welcome to java we are working on interface"
   }

   public void methodTwo(){
   
    System.out.println("we are in methodTwo");
   }

   public void display(){
 
    System.out.println("we are in display method ");
    }

    public static void main(String args[]){

      ExampleOnInterface2 ei2 = new ExampleOnInterface2();
        
        System.out.println(ei2.getMessage());
      
      ei2.methodTwo();
      ei2.display();
     

   }

}







create a object for class in other ways:
========================================

1)clone

2)factorymethod

3)Difference between Interface and abstract class


note:
=====
1)till jdk1.7 the interface contains only abstracts method
   from jdk 1.8 the sun people added one functionality in interface
   i.e, we can define instance methods inside interface
    
   and the defined methods inside interface must be default.

2) based on above concept execute one example and copy inthe
  document.


note:
=====
suppose a interface doesnot contain any abstract methods(empty)
then this type of interface called as marker interface or Tag interface

ex:
====

interface MyEx{


}

Ex:
===
Serializbale --java.io packages








  Encapsulation:
  ==============  

  Encapuslation is process of wrapping or binding the
  data members(variables) and member methods functionalities as single unit .

  ex:
  ====
  class

  In real time javabean class is called as Encapsulation class(we can achieve basic data hiding).

  what is javabean class ?
 
  it a class which contain private access modifiers of instance variables
  and based on that instance variable the class contains
  setter methods and  getter methods...etc

  note:
  =====
  In spring,Hibernate frameworks the java bean class will called as Pojo class
  (plain old java object)/DTO(Data Transfer Object) 

  ex:
  ===

  public class Employee{

  private int empid;
  private  String empName;
  private  float sal;

  //setters and getters

  public void setEmpId(int empid){

   this.empid=empid;

  }  
  public void setEmpName(String empName){

    this.empName=empName;
  }  

  public void setSal(float sal){

    this.sal = sal;
  }

  public int getEmpId(){
   
    return  this.empid;
 
   }

  public String getEmpName(){

     return this.empName;
  }
   public float getSal(){

       return this.sal;
   }


}

 note:
 ======
 In eclipseIDE we can generate getter and setter methods
 in class rightclik-->source-->generate setters and getters-->selectall
                                         -->finish.

    method signature:
    =================
    syntax :-
    ---------
    methodname(datatype of parameters );
    
    ex:
    ===
     public int getSum(int x,int y){

     //logic t perform sum of two numbers

     }

    method signature:
    ==================
     getSum(int,int);


   Polymorphism:
   =============

    polymorphism is means many forms.

    A superclass Reference variable holding its subclass object
    is called polymorphism.(polymorphic)

    we can acheive polymorphism in java using method overloading
     and method overrriding.

   1)method overloading or compile time polymorphism or early binding:
   ===================================================================

   A class which contain one or more methods which consists of same methodname
   and differ in arguments is called method overloading.

   we can acheive method overloading with a class.

   rules for methodloading:
   ========================

   1) different in no of arguments.
   2)different in  type of arguments,
 
   ex:
   ====

   1) create a class which contain multiple methods with same 
   method name to perform sum.

   sol:
   ----

    public class ExampleOnMethodOverload{

    public  int getSum(int x,int y){

      int z=x+y;
      
       return z;
      
    }

     public int getSum(int x,int y,int z)
     {
         return x+y+z;
     }
   
     public void  methodOne(int x,float y){
      
       System.out.println(x+" "+y);

      }

     public void methodOne(float x,int y){

      System.out.println(x+" "+y);   
    }
 
    }



  Automatic promotion types in method overloading:
  ==========================================

  if calling any method in method overloading ,compiler may not found the method based
  on referenced type compiler will not throw any errror message
  immediately,it will check for next level reference datatype based
  on the any method available it will execute other wise
  you will get error.


  byte ->short->int->long->float->double

   or 

  char ->int->long->float->double


 ex:
 ===
  public class ExampleTypePromotion {

  public void methodOne(int a){
    
  System.out.println("int value of a is "+a);    
     
  }

   public void methodOne(float a){
    
   System.out.println("float value of a "+a);    
     
   }

   public void methodOne(double a){
    
   System.out.println("double value of a "+a);    
     
   }

     public static void main(String args[]){
       
       ExampleTypePromotion ept =new ExampleTypePromotion();
      
      ept.methodOne(10); 
      ept.methodOne(10.5);

      ept.methodOne('a');

    

    }

  }

   note:
   ======
   compiler is responsible to perform or to execute the 
   methods based on method signature  is called method resolution
   (decision) ,the decision taken at compile time based on argument referenced type.


  MethodOverriding or run time ploymorphism or late binding:
  ===========================================================

  A method is override from parent class to child class with
  same method signature along with same arguments and 
  same return type of parent class method.(@override)

  using inheritance concept we can perform method overriding.

  ex:
  ===
   public class ExampleOnOverride
    {

    public void methodOne(){
        
     System.out.println("we are in method one of ExampleOnoverride");

    }
   }

   public class TestOnMethodOverride extends ExampleOnOverride
   {

     public void methodOne(){

     System.out.println("we are in methodOne of TestChild class");

    }

   public static void main(String args[]){

    TestOnMethodOverride tmd = new TestOnMethodOverride();
    
     tmd.methodOne();    
  
     
   }

  }


  note:
  ======

  In method overriding the method resolution(decision) will
  take at run time based on Object reference type.

  For A super class Reference variable Holding its sub class Object Execution:
  ===========================================================
  ExampleOnOverride tmd1 = new TestOnMethodOverride();
    tmd1.methodOne();

  1)first it will check the method reference in Super class  and based on
   method signature if available it will  check same methodSignature in child class(override) , 
   if available  it will execute child class method.

  2)If method signature not available in super class  and the same method signature 
   savailable in child class ,it will not execute child class method it will throw an error.





